/*
 * This file was generated by the Gradle 'init' task.
 *
 * This generated file contains a sample Java application project to get you started.
 * For more details take a look at the 'Building Java & JVM projects' chapter in the Gradle
 * User Manual available at https://docs.gradle.org/7.3/userguide/building_java_projects.html
 */

plugins {
    // Apply the application plugin to add support for building a CLI application in Java.
    id 'application'
    id 'com.gradleup.shadow' version '9.3.1'
}

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
}

def releaseVersion = (project.findProperty('releaseVersion') ?: '1.0.0').toString()
version = releaseVersion

def toInstallerVersion = { String v ->
    def cleaned = v.replaceAll('[^0-9.]', '')
    if (!cleaned) {
        return '1.0.0'
    }
    def parts = cleaned.tokenize('.').take(3).collect { it.isInteger() ? it : '0' }
    while (parts.size() < 3) {
        parts.add('0')
    }
    parts.join('.')
}

def installerVersion = toInstallerVersion(releaseVersion)

repositories {
    // Use Maven Central for resolving dependencies.
    mavenCentral()
}

dependencies {
    // Use JUnit Jupiter for testing.
    testImplementation platform('org.junit:junit-bom:5.14.2')
    testImplementation 'org.junit.jupiter:junit-jupiter'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'

    // This dependency is used by the application.
    // implementation'com.google.guava:guava:30.1.1-jre'

    implementation 'org.apache.httpcomponents.client5:httpclient5:5.6'
    implementation 'com.google.code.gson:gson:2.13.2'
    implementation 'com.mysql:mysql-connector-j:9.6.0'
    implementation 'org.postgresql:postgresql:42.7.9'
    implementation 'org.mariadb.jdbc:mariadb-java-client:3.5.7'
    implementation fileTree(dir: 'lib', include: '*.jar')
}

application {
    // Define the main class for the application.
    mainClass = 'app.Gop'
}

tasks.named('shadowJar') {
    archiveClassifier = 'all'
}

tasks.withType(Jar).configureEach {
    manifest {
        attributes(
            'Implementation-Title': 'gop',
            'Implementation-Version': project.version.toString()
        )
    }
}

def shadowJarFileName = tasks.named('shadowJar').get().archiveFileName.get()

def jpackageExecutable = {
    javaToolchains.launcherFor {
        languageVersion = JavaLanguageVersion.of(21)
    }.get().metadata.installationPath.file("bin/jpackage").asFile
}

def baseResourcesDir = layout.projectDirectory.dir("packaging/resources").asFile
def linuxResourcesDir = layout.projectDirectory.dir("packaging/resources-linux").asFile
def resourceArgsFor = { boolean linux ->
    File dir = (linux && linuxResourcesDir.exists()) ? linuxResourcesDir : baseResourcesDir
    return dir.exists() ? ['--resource-dir', dir.absolutePath] : []
}
def linuxPostInstall = layout.projectDirectory.file("packaging/scripts/linux-post-install.sh").asFile
def linuxPostUninstall = layout.projectDirectory.file("packaging/scripts/linux-post-uninstall.sh").asFile
def linuxAppImageDir = layout.buildDirectory.dir("jpackage/gop").get().asFile

tasks.register('jpackageAppImage', Exec) {
    dependsOn 'shadowJar'
    def outputDir = layout.buildDirectory.dir("jpackage").get().asFile
    doFirst {
        outputDir.mkdirs()
        def appImage = new File(outputDir, "gop.app")
        if (appImage.exists()) {
            appImage.deleteDir()
        }
    }
    def argsList = [
        jpackageExecutable(),
        '--type', 'app-image',
        '--input', layout.buildDirectory.dir("libs").get().asFile.absolutePath,
        '--dest', outputDir.absolutePath,
        '--name', 'gop',
        '--main-jar', shadowJarFileName,
        '--main-class', application.mainClass.get()
    ] + resourceArgsFor(false)
    commandLine(argsList)
}

def jpackageCommand = { String type, File outputDir, List<String> resourceArgs ->
    [
        jpackageExecutable(),
        '--type', type,
        '--input', layout.buildDirectory.dir("libs").get().asFile.absolutePath,
        '--dest', outputDir.absolutePath,
        '--name', 'gop',
        '--main-jar', shadowJarFileName,
        '--main-class', application.mainClass.get(),
        '--vendor', 'exgoya',
        '--description', 'Database monitoring console tool'
    ] + resourceArgs
}

def requireOs = { String label, boolean ok ->
    if (!ok) {
        throw new GradleException("jpackage '${label}' must be run on the target OS.")
    }
}

def jpackageLinuxAppImageCommand = { File outputDir, List<String> resourceArgs ->
    [
        jpackageExecutable(),
        '--type', 'app-image',
        '--input', layout.buildDirectory.dir("libs").get().asFile.absolutePath,
        '--dest', outputDir.absolutePath,
        '--name', 'gop',
        '--main-jar', shadowJarFileName,
        '--main-class', application.mainClass.get()
    ] + resourceArgs
}

def jpackageLinuxFromAppImage = { String type, File outputDir ->
    [
        jpackageExecutable(),
        '--type', type,
        '--app-image', linuxAppImageDir.absolutePath,
        '--dest', outputDir.absolutePath,
        '--name', 'gop',
        '--vendor', 'exgoya',
        '--description', 'Database monitoring console tool'
    ]
}

tasks.register('jpackageLinuxAppImage', Exec) {
    dependsOn 'shadowJar'
    def outputDir = layout.buildDirectory.dir("jpackage").get().asFile
    doFirst {
        outputDir.mkdirs()
        requireOs('app-image', org.gradle.internal.os.OperatingSystem.current().isLinux())
        if (linuxAppImageDir.exists()) {
            linuxAppImageDir.deleteDir()
        }
    }
    commandLine(jpackageLinuxAppImageCommand(outputDir, resourceArgsFor(true)))
}

tasks.register('prepareLinuxAppImage') {
    dependsOn 'jpackageLinuxAppImage'
    doLast {
        File resourceRoot = linuxResourcesDir.exists() ? linuxResourcesDir : baseResourcesDir
        if (resourceRoot.exists()) {
            File configDir = new File(resourceRoot, "config")
            if (configDir.exists()) {
                File targetDir = new File(linuxAppImageDir, "config")
                targetDir.mkdirs()
                copy {
                    from configDir
                    into targetDir
                }
            }
        }
    }
}

tasks.register('jpackageDmg', Exec) {
    dependsOn 'shadowJar'
    def outputDir = layout.buildDirectory.dir("jpackage").get().asFile
    doFirst {
        outputDir.mkdirs()
        requireOs('dmg', org.gradle.internal.os.OperatingSystem.current().isMacOsX())
    }
    commandLine(jpackageCommand('dmg', outputDir, resourceArgsFor(false)) + [
        '--app-version', releaseVersion,
        '--mac-app-category', 'public.app-category.developer-tools',
        '--mac-package-identifier', 'com.exgoya.gop'
    ])
}

tasks.register('jpackagePkg', Exec) {
    dependsOn 'shadowJar'
    def outputDir = layout.buildDirectory.dir("jpackage").get().asFile
    doFirst {
        outputDir.mkdirs()
        requireOs('pkg', org.gradle.internal.os.OperatingSystem.current().isMacOsX())
    }
    commandLine(jpackageCommand('pkg', outputDir, resourceArgsFor(false)) + [
        '--app-version', releaseVersion,
        '--mac-app-category', 'public.app-category.developer-tools',
        '--mac-package-identifier', 'com.exgoya.gop'
    ])
}

tasks.register('jpackageDeb', Exec) {
    dependsOn 'prepareLinuxAppImage'
    def outputDir = layout.buildDirectory.dir("jpackage").get().asFile
    doFirst {
        outputDir.mkdirs()
        requireOs('deb', org.gradle.internal.os.OperatingSystem.current().isLinux())
    }
    def argsList = jpackageLinuxFromAppImage('deb', outputDir) + [
        '--app-version', releaseVersion,
        '--linux-app-category', 'Development;System;'
    ]
    if (linuxPostInstall.exists()) {
        argsList += ['--linux-post-install', linuxPostInstall.absolutePath]
    }
    if (linuxPostUninstall.exists()) {
        argsList += ['--linux-post-uninstall', linuxPostUninstall.absolutePath]
    }
    commandLine(argsList)
}

tasks.register('jpackageRpm', Exec) {
    dependsOn 'prepareLinuxAppImage'
    def outputDir = layout.buildDirectory.dir("jpackage").get().asFile
    doFirst {
        outputDir.mkdirs()
        requireOs('rpm', org.gradle.internal.os.OperatingSystem.current().isLinux())
    }
    def argsList = jpackageLinuxFromAppImage('rpm', outputDir) + [
        '--app-version', releaseVersion,
        '--linux-app-category', 'Development;System;'
    ]
    if (linuxPostInstall.exists()) {
        argsList += ['--linux-post-install', linuxPostInstall.absolutePath]
    }
    if (linuxPostUninstall.exists()) {
        argsList += ['--linux-post-uninstall', linuxPostUninstall.absolutePath]
    }
    commandLine(argsList)
}

tasks.register('jpackageMsi', Exec) {
    dependsOn 'shadowJar'
    def outputDir = layout.buildDirectory.dir("jpackage").get().asFile
    doFirst {
        outputDir.mkdirs()
        requireOs('msi', org.gradle.internal.os.OperatingSystem.current().isWindows())
    }
    commandLine(jpackageCommand('msi', outputDir, resourceArgsFor(false)) + [
        '--app-version', installerVersion
    ])
}

tasks.register('jpackageWindows') {
    dependsOn 'jpackageMsi'
}

tasks.register('jpackageMac') {
    dependsOn 'jpackageDmg', 'jpackagePkg'
}

tasks.register('jpackageLinux') {
    dependsOn 'jpackageDeb', 'jpackageRpm'
}

tasks.named('build') {
    dependsOn 'shadowJar', 'shadowDistZip', 'jpackageAppImage'
}

tasks.named('test') {
    // Use JUnit Platform for unit tests.
    useJUnitPlatform()
}

distributions {
    main {
        contents {
            if (baseResourcesDir.exists()) {
                from(baseResourcesDir)
            }
        }
    }
}
