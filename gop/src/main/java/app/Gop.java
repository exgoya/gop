package app;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.sql.PreparedStatement;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.LinkedHashMap;
import java.util.Set;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import model.Config;
import model.Data;
import model.ResultCommon;
import model.SourceConfig;
import api.ApiServer;
import config.ConfigManager;
import db.Database;
import io.ReadLog;
import cli.CommandLineParser;
import log.CRetention;
import run.RunOutputFormatter;
import log.FileLogService;

/*
 * This Java source file was generated by the Gradle 'init' task.
 */

public class Gop {
	private static final Object PRINT_LOCK = new Object();

	public static void main(String[] args) throws Exception {
		new Gop().startApp(args);
	}

	public void startApp(String[] args) throws Exception {
		if (isVersionRequest(args)) {
			printVersion();
			return;
		}
		if (args.length < 1) {
			CommandLineParser.printHelp();
			System.exit(0);
		}
		String command = args[0];
		String[] subArgs = java.util.Arrays.copyOfRange(args, 1, args.length);
		CommandLineParser clp = new CommandLineParser(subArgs);

		boolean help = clp.getFlag("help");
		if (help) {
			CommandLineParser.printHelp();
			System.exit(0);
		}

		String configFile = clp.getArgumentValue("config")[0];
		if (configFile == null) {
			System.out.println("config file is required: -config <config file path>");
			CommandLineParser.printHelp();
			System.exit(0);
		}
		String log = clp.getArgumentValue("log")[0];
		int head = clp.getArgumentValueInt("head");
		int tail = clp.getArgumentValueInt("tail");
		String time1 = clp.getArgumentValue("time")[0];
		String time2 = clp.getArgumentValue("time")[1];
		String tagArg = clp.getArgumentValue("tag")[0];
		String nameArg = clp.getArgumentValue("name")[0];
		
		File rFile = new File(configFile);
		Gson gson = new GsonBuilder().setLenient().create();

		Config config = readAndConvConf(rFile, Config.class, gson);
		ConfigManager.ensureConfigId(config, rFile);

		if ("server".equalsIgnoreCase(command)) {
			CRetention cr = new CRetention(ConfigManager.resolveLogBasePath(config));
			cr.go(config.setting.retention);
			ConfigManager.ensureConfigFolderConsistency(config, rFile);
			startMonitoring(config, gson, false, false, true);
			ApiServer.startIfEnabled(config);
		} else if ("run".equalsIgnoreCase(command)) {
			int runIntervalSec = clp.getArgumentValueInt("interval");
			int runIntervalMs = clp.getArgumentValueInt("interval-ms");
			if (runIntervalMs > 0) {
				config.setting.timeInterval = runIntervalMs;
			} else if (runIntervalSec > 0) {
				config.setting.timeInterval = runIntervalSec * 1000;
			}
			runLoop(config, gson, false);
		} else if ("watch".equalsIgnoreCase(command)) {
			if (log == null) {
				System.out.println("watch requires -log <log file path>");
				System.exit(0);
			}
			ReadLog rl = new ReadLog(new File(log), gson, config);

			if (time1 != null && time2 != null) {
				LocalDateTime stTs = stringToDate(time1);
				LocalDateTime edTs = stringToDate(time2);
				rl.setRangeTimeMap(stTs, edTs);
				printTableMap(rl.rangeTimeMap, head, tail,config.setting.printCSV);
			} else if (nameArg != null) {
				String name = nameArg;
				rl.setNameMap(name);
				printTableMap(rl.nameMap, head, tail,config.setting.printCSV);
			} else if (tagArg != null) {
				String tag = tagArg;
				rl.setTagMap(tag);
				printTableMap(rl.tagMap, head, tail,config.setting.printCSV);
			} else {
				printTableMap(rl.timeMap, head, tail,config.setting.printCSV);
			}
		} else {
			System.out.println("invalid command: " + command);
			CommandLineParser.printHelp();
			System.exit(0);
		}
	}

	private static boolean isVersionRequest(String[] args) {
		if (args == null || args.length == 0) {
			return false;
		}
		for (String arg : args) {
			if (arg == null) {
				continue;
			}
			String value = arg.trim();
			if (value.equalsIgnoreCase("version") || value.equalsIgnoreCase("-version")
					|| value.equalsIgnoreCase("--version") || value.equalsIgnoreCase("-v")) {
				return true;
			}
		}
		return false;
	}

	private static void printVersion() {
		String version = getVersion();
		System.out.println("gop " + version);
	}

	private static String getVersion() {
		Package pkg = Gop.class.getPackage();
		if (pkg != null) {
			String v = pkg.getImplementationVersion();
			if (v != null && !v.isEmpty()) {
				return v;
			}
		}
		return "dev";
	}

	private void printInfo(SourceConfig source, Config config) {
		try {
			String currentPath = new java.io.File(".").getCanonicalPath();
			System.out.println("Current dir : " + currentPath);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		System.out.println("Source : " + (source.source == null ? "-" : source.source));
		System.out.println("Source jdbc url : " + source.jdbcSource.url);
		System.out.println("Write file : " + config.setting.fileLog.enable);
		System.out.println("Write file path : " + config.setting.fileLog.logPath);
	}

	private static void printTableMap(LinkedHashMap<LocalDateTime, ResultCommon[]> rangeTimeMap, int head, int tail, Boolean printCSV) {
		if (rangeTimeMap.isEmpty()) {
			System.out.println("no data!");
			System.exit(0);
		}
		Set<LocalDateTime> timeKeys = rangeTimeMap.keySet();
		int i = 0;
		boolean gColumn = true;

		Data sumDt = null;
		for (LocalDateTime key : timeKeys) {
			// System.out.println(key);

			if (head > 0) {
				if (i < head) {
					Data data = new Data(timestampToString(key), rangeTimeMap.get(key));
					gColumn = printTable(data, gColumn, printCSV);
					sumDt=sumData(sumDt,data);
					// System.out.println("head: " +i);
				}
			} else if (tail > 0) {
				if (timeKeys.size() - tail <= i) {
					Data data = new Data(timestampToString(key), rangeTimeMap.get(key));
					gColumn = printTable(data, gColumn, printCSV);
					sumDt=sumData(sumDt,data);
					// System.out.println("tail: " +i);
				}
			} else {
				Data data = new Data(timestampToString(key), rangeTimeMap.get(key));
				gColumn = printTable(data, gColumn, printCSV);
				sumDt=sumData(sumDt,data);
			}
			i++;
		}
		printTable(sumDt,false,printCSV);
		int avgNum=0;
		if(head > 0){
			avgNum=head;
		}else if (tail > 0){
			avgNum=tail;
		}else{
			avgNum=timeKeys.size();
		}
		printTable(avgData(sumDt,avgNum),false,printCSV);
	}

	private static Data avgData(Data sumDt, int size) {
		sumDt.time = "AVG:                     ";

		for (ResultCommon rc : sumDt.rc) {
			rc.value = rc.value/size;
		}

		return sumDt;
	}

	private static Data sumData(Data sumDt, Data data) {
		if(sumDt == null){
			sumDt = data;
			sumDt.time = "SUM:                     ";
		}else{
		   for (int i = 0; i < data.rc.length; i++) {
			sumDt.rc[i].value += data.rc[i].value;
		   }
		}
		return sumDt;
	}

	private static LocalDateTime stringToDate(String startSearchKey) {

		try {
			DateTimeFormatter formatDateTime = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSS");
			LocalDateTime localDateTime = LocalDateTime.from(formatDateTime.parse(startSearchKey));
			return localDateTime;
		} catch (java.time.format.DateTimeParseException e) {
			// TODO: handle exceptionA
			System.out.println("invalid time : " + startSearchKey);
			System.exit(0);
		}
		return null;
	}

	private void startMonitoring(Config config, Gson gson, boolean runOnce, boolean allowPrint, boolean allowFileLog) throws Exception {
		SourceConfig[] sources;
		if (config.sources != null && config.sources.length > 0) {
			sources = config.sources;
		} else {
			sources = new SourceConfig[] { buildSingleSource(config) };
		}
		if (runOnce) {
			java.util.concurrent.ConcurrentHashMap<String, Data> results = new java.util.concurrent.ConcurrentHashMap<>();
			Thread[] threads = new Thread[sources.length];
			for (int i = 0; i < sources.length; i++) {
				SourceConfig source = sources[i];
				printInfo(source, config);
				threads[i] = new Thread(() -> {
					try {
						Data data = collectOnce(config, source, gson);
						if (data != null) {
							results.put(source.source, data);
						}
					} catch (Exception e) {
						e.printStackTrace();
					}
				});
				threads[i].setDaemon(false);
				threads[i].start();
			}
			for (Thread t : threads) {
				t.join();
			}
			if (allowPrint && config.setting.consolePrint) {
				String cycleTime = java.time.format.DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSS")
						.format(java.time.LocalDateTime.now());
				RunOutputFormatter.printRunSections(new java.util.ArrayList<>(results.values()), config.setting.printCSV, cycleTime);
			}
		} else {
			Thread[] threads = new Thread[sources.length];
			for (int i = 0; i < sources.length; i++) {
				SourceConfig source = sources[i];
				printInfo(source, config);
				threads[i] = new Thread(() -> {
					try {
						gStampLog(config, source, gson, runOnce, allowPrint, allowFileLog);
					} catch (Exception e) {
						e.printStackTrace();
					}
				});
				threads[i].setDaemon(false);
				threads[i].start();
			}
		}
	}

	private void runLoop(Config config, Gson gson, boolean showInfo) throws Exception {
		SourceConfig[] sources;
		if (config.sources != null && config.sources.length > 0) {
			sources = config.sources;
		} else {
			sources = new SourceConfig[] { buildSingleSource(config) };
		}
		if (showInfo) {
			for (SourceConfig source : sources) {
				printInfo(source, config);
			}
		}
		java.util.concurrent.ConcurrentHashMap<String, Database.ConnAndStmt> connCache = new java.util.concurrent.ConcurrentHashMap<>();
		Runtime.getRuntime().addShutdownHook(new Thread(() -> closeRunConnections(connCache)));
		java.util.concurrent.ExecutorService exec = java.util.concurrent.Executors
				.newFixedThreadPool(Math.max(1, sources.length));
		Runtime.getRuntime().addShutdownHook(new Thread(() -> exec.shutdownNow()));
		while (true) {
			java.util.concurrent.ConcurrentHashMap<String, Data> results = new java.util.concurrent.ConcurrentHashMap<>();
			java.util.List<java.util.concurrent.Future<Data>> futures = new java.util.ArrayList<>();
			for (int i = 0; i < sources.length; i++) {
				SourceConfig source = sources[i];
				futures.add(exec.submit(() -> collectOnceReuse(config, source, gson, connCache)));
			}
			for (java.util.concurrent.Future<Data> f : futures) {
				try {
					Data data = f.get();
					if (data != null) {
						String key = data.source == null ? "default" : data.source;
						results.put(key, data);
					}
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
			if (config.setting.consolePrint) {
				String cycleTime = java.time.format.DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSS")
						.format(java.time.LocalDateTime.now());
				RunOutputFormatter.printRunSections(new java.util.ArrayList<>(results.values()), config.setting.printCSV, cycleTime);
			}
			Thread.sleep(config.setting.timeInterval);
		}
	}


	private static SourceConfig buildSingleSource(Config config) {
		SourceConfig source = new SourceConfig();
		source.source = config.setting.source == null ? "default" : config.setting.source;
		source.jdbcSource = config.setting.jdbcSource;
		source.measure = config.measure;
		return source;
	}

	private static void gStampLog(Config config, SourceConfig source, Gson gson, boolean runOnce, boolean allowPrint, boolean allowFileLog)
			throws Exception {

		// db
		Database db = new Database(source.jdbcSource, source.measure, source.source);

		int printRow = 0;
		Data beforeData = new Data(null, null);
		Data calData = new Data(null, null);

		PreparedStatement[] arrPstmt = null;

		arrPstmt = db.createConAndPstmt(db);
		boolean firstSkip = true;
		boolean gColumn = true;

		while (true) {
			Data data = null;
			int i = 0;
			do {
				data = db.getCommonQuery(arrPstmt);
				if (data != null) {
					continue;
				}
				arrPstmt = db.createConAndPstmt(db);

				System.out.println("getCommonQuery error retry cnt : " + i);
				i++;
				Thread.sleep(1000);
			} while (data == null);

			// ResultCommon[] rc2 = db.getOsQuery();

			// write output file (json)
			if (beforeData.rc == null) {
				calData = data.newInstance(data);
				beforeData = data.newInstance(data);
			} else {
				calData = diffDataCal(data, beforeData, source.measure);
				beforeData = data.newInstance(data);
			}

			if (!firstSkip || runOnce){
				if (allowFileLog && config.setting.fileLog.enable) {
					FileLogService.writeJson(calData, gson, config, source.measure);
				}
				// print console (table)
				if (allowPrint && config.setting.consolePrint) {
					gColumn = printTable(calData,gColumn,config.setting.printCSV);
					printRow++;
					if (printRow % config.setting.pageSize == 0) {
						gColumn = true;
					}
				}
			}else{
				firstSkip=false;
			}
			data = null;
			// rc2 = null;
			if (runOnce) {
				break;
			}
			Thread.sleep(config.setting.timeInterval);
		}
	}

	private static Data collectOnce(Config config, SourceConfig source, Gson gson) throws Exception {
		Database db = new Database(source.jdbcSource, source.measure, source.source);
		Database.ConnAndStmt cas = db.createConAndPstmtWithConnection();
		Data data = null;
		int i = 0;
		try {
			do {
				data = db.getCommonQuery(cas.stmts);
				if (data != null) {
					break;
				}
				cas = db.createConAndPstmtWithConnection();
				System.out.println("getCommonQuery error retry cnt : " + i);
				i++;
				Thread.sleep(1000);
			} while (data == null);
			return data;
		} finally {
			if (cas != null && cas.con != null) {
				try {
					cas.con.close();
				} catch (Exception ignored) {
				}
			}
		}
	}

	private static Data collectOnceReuse(Config config, SourceConfig source, Gson gson,
			java.util.concurrent.ConcurrentHashMap<String, Database.ConnAndStmt> connCache) throws Exception {
		Database db = new Database(source.jdbcSource, source.measure, source.source);
		String key = source.source == null ? "default" : source.source;
		Database.ConnAndStmt cas = connCache.get(key);
		if (cas == null || cas.con == null || cas.con.isClosed()) {
			cas = db.createConAndPstmtWithConnection();
			connCache.put(key, cas);
		}
		Data data = null;
		int i = 0;
		do {
			data = db.getCommonQuery(cas.stmts);
			if (data != null) {
				break;
			}
			closeConn(cas);
			cas = db.createConAndPstmtWithConnection();
			connCache.put(key, cas);
			System.out.println("getCommonQuery error retry cnt : " + i);
			i++;
			Thread.sleep(1000);
		} while (data == null);
		return data;
	}

	private static void closeConn(Database.ConnAndStmt cas) {
		if (cas == null || cas.con == null) {
			return;
		}
		try {
			cas.con.close();
		} catch (Exception ignored) {
		}
	}

	private static void closeRunConnections(java.util.concurrent.ConcurrentHashMap<String, Database.ConnAndStmt> connCache) {
		for (Database.ConnAndStmt cas : connCache.values()) {
			closeConn(cas);
		}
	}

	private static Data diffDataCal(Data data, Data beforeData, model.Measure[] measure) {
		// Data tempData = new Data(data.time, data.rc);
		// ResultCommon[] rc = new ResultCommon[data.rc.length];
		// Data tempData = new Data(data.time, rc);
		Data cal = data.newInstance(data);
		for (int i = 0; i < data.rc.length; i++) {
			if (measure[i].diff) {
				cal.rc[i].value = data.rc[i].value - beforeData.rc[i].value;
			}
		}
		return cal;
	}

	private static String timestampToString(LocalDateTime timestamp) {
		DateTimeFormatter formatDateTime = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSS");
		return formatDateTime.format(timestamp);
	}

	private static Config readAndConvConf(File rFile, Class<Config> class1, Gson gson) throws FileNotFoundException {
		FileInputStream fis = new FileInputStream(rFile);
		InputStreamReader isr = new InputStreamReader(fis, StandardCharsets.UTF_8);
		BufferedReader reader = new BufferedReader(isr);

		return gson.fromJson(reader, Config.class);
	}

	private static void validateSourceDir(String source) {
		ConfigManager.validateId("source id", source);
	}

	private static Boolean printTable(Data data,Boolean gColumn,Boolean printCSV) {
		synchronized (PRINT_LOCK) {
		// TODO Auto-generated method stub
		String[] column = new String[data.rc.length];
		String[] row = new String[data.rc.length];

		for (int i = 0; i < data.rc.length; i++) {
			if (data.rc[i] != null) {
				column[i] = data.rc[i].measure;
				if(!printCSV){
					row[i] = alertFormat(data.rc[i].value, data.rc[i].alert);
				}else{
					row[i] = (","+data.rc[i].value);
				}
				// System.out.println(rc[i].toString());
			}
		}

		int i = 0;
		if (gColumn == true) {
			// System.out.println("** instance name :" + gName);

			System.out.println("");
			if(!printCSV){
				System.out.format("%24s  ", ANSI_GREEN + "time" + ANSI_RESET);
				System.out.format("%18s  ", ANSI_GREEN + "source" + ANSI_RESET);
				for (i = 0; i < row.length; i++) {
					if(column[i] != null) {
						System.out.format("%18s  ", ANSI_GREEN + column[i] + ANSI_RESET);
					}
				}
			}else{
				System.out.format("time");
				System.out.print(",source");
					for (i = 0; i < row.length; i++) {
						if(printCSV){
							System.out.print(","+column[i]);
						}else{
							if(column[i] != null) {
								System.out.format("%23s", ANSI_GREEN + column[i] + ANSI_RESET);
							}	
						}
					}
			}
			
			System.out.format("%n");
			gColumn = false;
		}

		for (i = 0; i < data.rc.length; i++) {
			if (data.rc[i] != null) {
				// System.out.println(rc[i].toString());
				if(!printCSV){
					System.out.format("%24s  ", ANSI_GREEN + data.time + ANSI_RESET);
					System.out.format("%18s  ", ANSI_GREEN + (data.source == null ? "-" : data.source) + ANSI_RESET);
				}else{
					System.out.format(data.time);
					System.out.print("," + (data.source == null ? "-" : data.source));
				}
				break;
			}
		}

		for (i = 0; i < row.length; i++) {
			if (row[i] != null) {
				if(!printCSV){
					System.out.format("%18s  ", row[i]);
				}else{
					System.out.format(row[i]);
				}
			}
		}
		System.out.format("%n");
		return gColumn;
		}
	}

	private static String alertFormat(long value, boolean alert) {
		String temp = null;
		if (alert) {
			temp = ANSI_RED + String.valueOf(value) + ANSI_RESET;
		} else {
			temp = ANSI_WHITE + String.valueOf(value) + ANSI_RESET;
		}
		return temp;
	}

	public Object startApp(String string, String string2) {
		return null;
	}
	
	public static final String ANSI_RESET = "\u001B[0m";
	public static final String ANSI_BLACK = "\u001B[30m";
	public static final String ANSI_RED = "\u001B[31m";
	public static final String ANSI_GREEN = "\u001B[32m";
	public static final String ANSI_YELLOW = "\u001B[33m";
	public static final String ANSI_BLUE = "\u001B[34m";
	public static final String ANSI_PURPLE = "\u001B[35m";
	public static final String ANSI_CYAN = "\u001B[36m";
	public static final String ANSI_WHITE = "\u001B[37m";
}
