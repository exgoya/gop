package app;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.RandomAccessFile;
import java.nio.charset.StandardCharsets;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import model.ActionV2;
import model.Config;
import model.Data;
import model.Measure;
import model.MeasureV2;
import model.ResultCommon;
import model.RuleV2;
import model.SourceConfig;
import model.TargetV2;
import api.ApiServer;
import config.ConfigManager;
import db.Database;
import io.ReadLog;
import io.ReadOs;
import cli.CommandLineParser;
import log.CRetention;
import run.RunOutputFormatter;
import log.FileLogService;

/*
 * This Java source file was generated by the Gradle 'init' task.
 */

public class Gop {
	private static final Object PRINT_LOCK = new Object();
	private static final java.util.concurrent.ConcurrentHashMap<String, Long> V2_PREVIOUS_VALUES = new java.util.concurrent.ConcurrentHashMap<>();

	public static void main(String[] args) throws Exception {
		new Gop().startApp(args);
	}

	public void startApp(String[] args) throws Exception {
		if (isVersionRequest(args)) {
			printVersion();
			return;
		}
		if (args.length < 1) {
			CommandLineParser.printHelp();
			System.exit(0);
		}
		String command = args[0];
		String[] subArgs = java.util.Arrays.copyOfRange(args, 1, args.length);

		if (hasHelpFlag(subArgs)) {
			CommandLineParser.printHelp();
			System.exit(0);
		}

		if ("ls".equalsIgnoreCase(command)) {
			handleLs(subArgs);
			return;
		}
		if ("watch".equalsIgnoreCase(command)) {
			handleWatch(subArgs);
			return;
		}

		CommandLineParser clp = new CommandLineParser(subArgs);

		String configFile = clp.getArgumentValue("config")[0];
		if (configFile == null) {
			System.out.println("config file is required: -config <config file path>");
			CommandLineParser.printHelp();
			System.exit(0);
		}
		File rFile = new File(configFile);
		Gson gson = new GsonBuilder().setLenient().create();

		Config config = readAndConvConf(rFile, Config.class, gson);
		ConfigManager.ensureConfigId(config, rFile);

		if ("server".equalsIgnoreCase(command)) {
			CRetention cr = new CRetention(ConfigManager.resolveLogBasePath(config));
			cr.go(config.setting.retention);
			ConfigManager.ensureConfigFolderConsistency(config, rFile);
			startMonitoring(config, gson, false, false, true);
			ApiServer.startIfEnabled(config);
		} else if ("run".equalsIgnoreCase(command)) {
			int runIntervalSec = clp.getArgumentValueInt("interval");
			int runIntervalMs = clp.getArgumentValueInt("interval-ms");
			if (runIntervalMs > 0) {
				config.setting.timeInterval = runIntervalMs;
			} else if (runIntervalSec > 0) {
				config.setting.timeInterval = runIntervalSec * 1000;
			}
			runLoop(config, gson, false);
		} else {
			System.out.println("invalid command: " + command);
			CommandLineParser.printHelp();
			System.exit(0);
		}
	}

	private static void handleLs(String[] args) {
		LsArgs ls = parseLsArgs(args);
		File logRoot = resolveLogRoot(ls.path);
		String target = ls.target == null ? "" : ls.target.trim();
		List<String> parts = splitPath(target);

		if (isConfigDir(logRoot)) {
			handleLsInConfig(logRoot, parts, target);
			return;
		}

		if (parts.isEmpty()) {
			printConfigList(logRoot);
			return;
		}

		File configDir = findConfigDir(logRoot, parts.get(0));
		if (configDir != null) {
			handleLsInConfig(configDir, parts.subList(1, parts.size()), target);
			return;
		}

		// fallback: source-only view across configs
		handleLsSourceOnly(logRoot, parts, target);
	}

	private static void handleWatch(String[] args) throws Exception {
		WatchArgs wa = parseWatchArgs(args);
		if (wa.mode != null && !wa.mode.equalsIgnoreCase("tail")) {
			System.out.println("invalid watch mode: " + wa.mode);
			System.exit(0);
		}
		File logRoot = resolveLogRoot(wa.path);
		File configDir = null;
		if (wa.configName != null && !wa.configName.trim().isEmpty()) {
			ConfigManager.validateId("config name", wa.configName);
			configDir = findConfigDir(logRoot, wa.configName.trim());
			if (configDir == null) {
				System.out.println("config not found: " + wa.configName);
				return;
			}
		}

		if (wa.follow) {
			if (wa.source == null || wa.source.trim().isEmpty()) {
				System.out.println("follow requires -source <sourceId>");
				return;
			}
			validateSourceDir(wa.source);
			followWatch(wa, logRoot, configDir);
			return;
		}

		if (wa.source == null || wa.source.trim().isEmpty()) {
			if (wa.file != null) {
				System.out.println("watch without -source cannot use -f");
				return;
			}
			if (configDir == null) {
				List<File> configs = listConfigDirs(logRoot);
				if (configs.isEmpty()) {
					System.out.println("no configs found under: " + (logRoot == null ? "-" : logRoot.getPath()));
					return;
				}
				if (configs.size() > 1) {
					System.out.println("multiple configs found. use -config <name>");
					printConfigList(logRoot);
					return;
				}
				configDir = configs.get(0);
			}
			watchAllSources(configDir, wa);
			return;
		}

		validateSourceDir(wa.source);
		watchSingleSource(wa, logRoot, configDir, true);
	}

	private static boolean hasHelpFlag(String[] args) {
		if (args == null) {
			return false;
		}
		for (String arg : args) {
			if (arg == null) {
				continue;
			}
			String v = arg.trim();
			if (v.equalsIgnoreCase("-help") || v.equalsIgnoreCase("--help") || v.equalsIgnoreCase("-h")) {
				return true;
			}
		}
		return false;
	}

	private static File resolveLogRoot(String path) {
		String base = path;
		if (base == null || base.trim().isEmpty()) {
			String env = System.getenv("GOP_LOG_PATH");
			base = (env == null || env.trim().isEmpty()) ? "data" : env.trim();
		}
		return new File(base);
	}

	private static LsArgs parseLsArgs(String[] args) {
		LsArgs ls = new LsArgs();
		if (args == null) {
			return ls;
		}
		for (int i = 0; i < args.length; i++) {
			String token = args[i];
			if (token == null) {
				continue;
			}
			if (token.startsWith("-")) {
				if (token.equalsIgnoreCase("-path")) {
					if (i + 1 >= args.length) {
						System.out.println("ls requires -path <log root>");
						System.exit(0);
					}
					ls.path = args[++i];
				} else {
					System.out.println("invalid ls option: " + token);
					System.exit(0);
				}
				continue;
			}
			if (ls.target == null) {
				ls.target = token;
			} else {
				System.out.println("invalid ls target: " + token);
				System.exit(0);
			}
		}
		return ls;
	}

	private static WatchArgs parseWatchArgs(String[] args) {
		WatchArgs wa = new WatchArgs();
		if (args == null) {
			return wa;
		}
		for (int i = 0; i < args.length; i++) {
			String token = args[i];
			if (token == null) {
				continue;
			}
			if (!token.startsWith("-")) {
				if (wa.mode == null) {
					wa.mode = token.trim().toLowerCase();
				} else {
					System.out.println("invalid watch token: " + token);
					System.exit(0);
				}
				continue;
			}
			switch (token) {
			case "-config":
			case "-config-name":
				wa.configName = requireValue(args, ++i, token);
				break;
			case "-source":
				wa.source = requireValue(args, ++i, token);
				break;
			case "-f":
				if (i + 1 < args.length && args[i + 1] != null && !args[i + 1].startsWith("-")) {
					wa.file = args[++i];
				} else {
					wa.follow = true;
				}
				break;
			case "-file":
				wa.file = requireValue(args, ++i, token);
				break;
			case "-path":
				wa.path = requireValue(args, ++i, token);
				break;
			case "-time":
				wa.time1 = requireValue(args, ++i, token);
				wa.time2 = requireValue(args, ++i, token);
				break;
			case "-name":
				wa.name = requireValue(args, ++i, token);
				break;
			case "-tag":
				wa.tag = requireValue(args, ++i, token);
				break;
			case "-head":
				wa.head = parseIntArg(requireValue(args, ++i, token), token);
				break;
			case "-tail":
				wa.tail = parseIntArg(requireValue(args, ++i, token), token);
				break;
			case "-n":
				wa.tail = parseIntArg(requireValue(args, ++i, token), token);
				break;
			case "-csv":
				wa.csv = true;
				break;
			case "-follow":
			case "-F":
				wa.follow = true;
				break;
			default:
				System.out.println("invalid watch option: " + token);
				System.exit(0);
			}
		}
		return wa;
	}

	private static String requireValue(String[] args, int index, String flag) {
		if (index >= args.length) {
			System.out.println("missing value for " + flag);
			System.exit(0);
		}
		return args[index];
	}

	private static void followWatch(WatchArgs wa, File logRoot, File configOverride) throws Exception {
		if (wa.time1 != null || wa.time2 != null) {
			System.out.println("follow mode does not support -time");
			System.exit(0);
		}
		if (wa.head != null && wa.head > 0) {
			System.out.println("follow mode does not support -head (use -tail)");
			System.exit(0);
		}
		int tail = wa.tail == null || wa.tail <= 0 ? 20 : wa.tail;
		File configDir = null;
		File targetFile = null;
		if (wa.file != null) {
			targetFile = new File(wa.file);
		} else {
			if (configOverride != null) {
				configDir = configOverride;
			} else {
				ConfigChoice choice = findBestConfigForSource(logRoot, wa.source);
				if (choice == null) {
					System.out.println("no log files found for source=" + wa.source);
					return;
				}
				configDir = choice.configDir;
				if (choice.multiple) {
					System.out.println("using config: " + configDir.getName());
				}
			}
			targetFile = findLatestLogFile(configDir, wa.source);
		}
		if (targetFile == null || !targetFile.exists()) {
			String scope = configDir == null ? "" : (" (config " + configDir.getName() + ")");
			System.out.println("log file not found for source=" + wa.source + scope);
			return;
		}

		Gson gson = new GsonBuilder().setLenient().create();
		List<String> lines = readLastLines(targetFile, tail);
		boolean gColumn = true;
		boolean matchSeen = false;
		for (String line : lines) {
			Data data = parseLogLine(line, gson);
			if (data == null) {
				continue;
			}
			Data filtered = filterData(data, wa);
			if (filtered == null) {
				continue;
			}
			matchSeen = true;
			gColumn = printTable(filtered, gColumn, wa.csv);
		}
		if (isFilterActive(wa) && !matchSeen) {
			printFilterError(wa);
			System.exit(0);
		}
		followFile(targetFile, gson, wa, gColumn);
	}

	private static void followFile(File file, Gson gson, WatchArgs wa, boolean gColumn) throws Exception {
		long pointer = 0L;
		try (RandomAccessFile raf = new RandomAccessFile(file, "r")) {
			pointer = raf.length();
			raf.seek(pointer);
			while (true) {
				String line = raf.readLine();
				if (line == null) {
					long len = raf.length();
					if (len < pointer) {
						raf.seek(0);
						pointer = 0;
					}
					Thread.sleep(500);
					continue;
				}
				pointer = raf.getFilePointer();
				String decoded = new String(line.getBytes(StandardCharsets.ISO_8859_1), StandardCharsets.UTF_8);
				Data data = parseLogLine(decoded, gson);
				if (data == null) {
					continue;
				}
				Data filtered = filterData(data, wa);
				if (filtered == null) {
					continue;
				}
				gColumn = printTable(filtered, gColumn, wa.csv);
			}
		}
	}

	private static List<String> readLastLines(File file, int maxLines) throws IOException {
		List<String> lines = new ArrayList<>();
		if (file == null || !file.exists() || maxLines <= 0) {
			return lines;
		}
		try (RandomAccessFile raf = new RandomAccessFile(file, "r")) {
			long pointer = raf.length() - 1;
			StringBuilder sb = new StringBuilder();
			int lineCount = 0;
			while (pointer >= 0 && lineCount < maxLines) {
				raf.seek(pointer);
				int read = raf.read();
				if (read == '\n') {
					if (sb.length() > 0) {
						lines.add(sb.reverse().toString());
						sb.setLength(0);
						lineCount++;
					}
				} else if (read != '\r') {
					sb.append((char) read);
				}
				pointer--;
			}
			if (sb.length() > 0 && lineCount < maxLines) {
				lines.add(sb.reverse().toString());
			}
		}
		Collections.reverse(lines);
		return lines;
	}

	private static Data parseLogLine(String line, Gson gson) {
		if (line == null) {
			return null;
		}
		String trimmed = line.trim();
		if (trimmed.isEmpty()) {
			return null;
		}
		try {
			return gson.fromJson(trimmed, Data.class);
		} catch (com.google.gson.JsonSyntaxException e) {
			return null;
		}
	}

	private static boolean isFilterActive(WatchArgs wa) {
		return wa != null && (wa.name != null || wa.tag != null);
	}

	private static void printFilterError(WatchArgs wa) {
		if (wa == null) {
			return;
		}
		if (wa.name != null) {
			System.out.println("measure :" + wa.name + " is not valid");
		} else if (wa.tag != null) {
			System.out.println("tag :" + wa.tag + " is not valid");
		}
	}

	private static Data filterData(Data data, WatchArgs wa) {
		if (data == null || data.rc == null) {
			return null;
		}
		if (wa == null || (wa.name == null && wa.tag == null)) {
			return data;
		}
		ResultCommon[] rc = data.rc;
		ResultCommon[] filtered = new ResultCommon[rc.length];
		boolean any = false;
		if (wa.name != null) {
			for (int i = 0; i < rc.length; i++) {
				if (rc[i] != null && wa.name.equals(rc[i].measure)) {
					filtered[i] = rc[i];
					any = true;
				}
			}
		} else if (wa.tag != null) {
			for (int i = 0; i < rc.length; i++) {
				if (rc[i] != null && wa.tag.equals(rc[i].tag)) {
					filtered[i] = rc[i];
					any = true;
				}
			}
		}
		if (!any) {
			return null;
		}
		return new Data(data.time, data.source, filtered);
	}

	private static void watchAllSources(File configDir, WatchArgs wa) throws Exception {
		if (configDir == null) {
			System.out.println("config not found");
			return;
		}
		java.util.Map<String, LocalDate> latest = latestLogBySourceInConfig(configDir);
		if (latest.isEmpty()) {
			System.out.println("no sources found under: " + configDir.getPath());
			return;
		}
		List<String> sources = new ArrayList<>(latest.keySet());
		Collections.sort(sources);
		String original = wa.source;
		boolean first = true;
		for (String source : sources) {
			if (!first) {
				System.out.println("");
			}
			first = false;
			System.out.println("source: " + source);
			wa.source = source;
			watchSingleSource(wa, null, configDir, false);
		}
		wa.source = original;
	}

	private static boolean watchSingleSource(WatchArgs wa, File logRoot, File configOverride, boolean strict)
			throws Exception {
		List<File> logFiles = new ArrayList<>();
		File configDir = configOverride;
		if (wa.file != null) {
			File target = new File(wa.file);
			if (!target.exists()) {
				System.out.println("log file not found: " + wa.file);
				return false;
			}
			logFiles.add(target);
		} else {
			LocalDateTime stTs = null;
			LocalDateTime edTs = null;
			if (wa.time1 != null || wa.time2 != null) {
				if (wa.time1 == null || wa.time2 == null) {
					System.out.println("watch requires both start and end time");
					System.exit(0);
				}
				stTs = stringToDate(wa.time1);
				edTs = stringToDate(wa.time2);
				if (edTs.isBefore(stTs)) {
					System.out.println("invalid time range: end < start");
					System.exit(0);
				}
			}
			if (configDir == null) {
				ConfigChoice choice = findBestConfigForSource(logRoot, wa.source);
				if (choice == null) {
					System.out.println("no log files found for source=" + wa.source);
					return false;
				}
				configDir = choice.configDir;
				if (choice.multiple) {
					System.out.println("using config: " + configDir.getName());
				}
			}
			logFiles = resolveLogFiles(configDir, wa.source, stTs, edTs);
		}

		if (logFiles.isEmpty()) {
			String scope = configDir == null ? "" : (" (config " + configDir.getName() + ")");
			System.out.println("no log files found for source=" + wa.source + scope);
			return false;
		}

		int head = wa.head == null ? 0 : wa.head;
		int tail = wa.tail == null ? 0 : wa.tail;
		boolean hasRange = wa.time1 != null && wa.time2 != null;
		if (head == 0 && tail == 0 && !hasRange) {
			tail = 20;
		}

		Gson gson = new GsonBuilder().setLenient().create();
		ReadLog rl = new ReadLog(logFiles, gson);
		LinkedHashMap<LocalDateTime, ResultCommon[]> map = selectWatchMap(rl, wa, strict);
		if (map == null) {
			return false;
		}
		if (map.isEmpty()) {
			if (strict) {
				System.out.println("no data!");
				System.exit(0);
			} else {
				System.out.println("no data for source=" + wa.source);
				return false;
			}
		}
		printTableMap(map, head, tail, wa.csv);
		return true;
	}

	private static LinkedHashMap<LocalDateTime, ResultCommon[]> selectWatchMap(ReadLog rl, WatchArgs wa, boolean strict) {
		if (wa.time1 != null && wa.time2 != null) {
			LocalDateTime stTs = stringToDate(wa.time1);
			LocalDateTime edTs = stringToDate(wa.time2);
			rl.setRangeTimeMap(stTs, edTs);
			return rl.rangeTimeMap;
		}
		if (wa.name != null) {
			if (!hasMeasure(rl.timeMap, wa.name)) {
				handleInvalidFilter(wa, strict);
				return null;
			}
			rl.setNameMap(wa.name);
			return rl.nameMap;
		}
		if (wa.tag != null) {
			if (!hasTag(rl.timeMap, wa.tag)) {
				handleInvalidFilter(wa, strict);
				return null;
			}
			rl.setTagMap(wa.tag);
			return rl.tagMap;
		}
		return rl.timeMap;
	}

	private static boolean hasMeasure(LinkedHashMap<LocalDateTime, ResultCommon[]> map, String name) {
		if (map == null || name == null) {
			return false;
		}
		for (ResultCommon[] values : map.values()) {
			if (values == null) {
				continue;
			}
			for (ResultCommon rc : values) {
				if (rc != null && name.equals(rc.measure)) {
					return true;
				}
			}
		}
		return false;
	}

	private static boolean hasTag(LinkedHashMap<LocalDateTime, ResultCommon[]> map, String tag) {
		if (map == null || tag == null) {
			return false;
		}
		for (ResultCommon[] values : map.values()) {
			if (values == null) {
				continue;
			}
			for (ResultCommon rc : values) {
				if (rc != null && tag.equals(rc.tag)) {
					return true;
				}
			}
		}
		return false;
	}

	private static void handleInvalidFilter(WatchArgs wa, boolean strict) {
		printFilterError(wa);
		if (strict) {
			System.exit(0);
		}
	}

	private static Integer parseIntArg(String value, String flag) {
		try {
			return Integer.parseInt(value);
		} catch (NumberFormatException e) {
			System.out.println("invalid number for " + flag + ": " + value);
			System.exit(0);
			return 0;
		}
	}

	private static List<String> splitPath(String target) {
		List<String> parts = new ArrayList<>();
		if (target == null || target.trim().isEmpty()) {
			return parts;
		}
		for (String part : target.split("/")) {
			if (!part.isEmpty()) {
				parts.add(part);
			}
		}
		return parts;
	}

	private static void handleLsInConfig(File configDir, List<String> parts, String target) {
		if (parts.isEmpty()) {
			printConfigSources(configDir);
			return;
		}
		validateSourceDir(parts.get(0));
		if (parts.size() == 1) {
			printSourceYearsInConfig(configDir, parts.get(0));
			return;
		}
		if (parts.size() == 2) {
			printSourceMonthsInConfig(configDir, parts.get(0), parts.get(1));
			return;
		}
		if (parts.size() == 3) {
			printSourceLogsInConfig(configDir, parts.get(0), parts.get(1), parts.get(2));
			return;
		}
		System.out.println("invalid ls target: " + target);
		CommandLineParser.printHelp();
	}

	private static void handleLsSourceOnly(File logRoot, List<String> parts, String target) {
		validateSourceDir(parts.get(0));
		if (parts.size() == 1) {
			printSourceYearsGlobal(logRoot, parts.get(0));
			return;
		}
		if (parts.size() == 2) {
			printSourceMonthsGlobal(logRoot, parts.get(0), parts.get(1));
			return;
		}
		if (parts.size() == 3) {
			printSourceLogsGlobal(logRoot, parts.get(0), parts.get(1), parts.get(2));
			return;
		}
		System.out.println("invalid ls target: " + target);
		CommandLineParser.printHelp();
	}

	private static void printConfigList(File logRoot) {
		List<File> configs = listConfigDirs(logRoot);
		if (configs.isEmpty()) {
			System.out.println("no configs found under: " + (logRoot == null ? "-" : logRoot.getPath()));
			return;
		}
		configs.sort(Comparator.comparing(File::getName));
		for (File configDir : configs) {
			java.util.Map<String, LocalDate> latestBySource = latestLogBySourceInConfig(configDir);
			LocalDate date = maxDate(latestBySource.values());
			String dateStr = date == null ? "-" : date.toString();
			String summary = formatSourceSummary(latestBySource.keySet(), 3);
			System.out.println(dateStr + "  " + configDir.getName() + "/  " + summary);
		}
	}

	private static void printConfigSources(File configDir) {
		java.util.Map<String, LocalDate> latest = latestLogBySourceInConfig(configDir);
		List<String> sources = new ArrayList<>(latest.keySet());
		Collections.sort(sources);
		for (String source : sources) {
			LocalDate date = latest.get(source);
			String dateStr = date == null ? "-" : date.toString();
			System.out.println(dateStr + "  " + source + "/");
		}
		if (sources.isEmpty()) {
			System.out.println("no sources found under: " + (configDir == null ? "-" : configDir.getPath()));
		}
	}

	private static void printSourceYearsInConfig(File configDir, String source) {
		List<String> years = listYearsForSourceInConfig(configDir, source);
		if (years.isEmpty()) {
			System.out.println("no logs for source: " + source);
			return;
		}
		System.out.println(source + "/");
		for (String year : years) {
			System.out.println(year + "/");
		}
	}

	private static void printSourceMonthsInConfig(File configDir, String source, String year) {
		List<String> months = listMonthsForSourceInConfig(configDir, source, year);
		if (months.isEmpty()) {
			System.out.println("no logs for source: " + source + " year=" + year);
			return;
		}
		System.out.println(source + "/" + year + "/");
		for (String month : months) {
			System.out.println(month + "/");
		}
	}

	private static void printSourceLogsInConfig(File configDir, String source, String year, String month) {
		List<File> logs = listLogsForSourceInConfig(configDir, source, year, month);
		if (logs.isEmpty()) {
			System.out.println("no logs for source: " + source + " " + year + "/" + month);
			return;
		}
		for (File log : logs) {
			LocalDate date = parseDateFromLogFile(log.getName());
			String dateStr = date == null ? "-" : date.toString();
			System.out.println(dateStr + "  " + log.getName());
		}
	}

	private static void printSourceYearsGlobal(File logRoot, String source) {
		List<String> years = listYearsForSourceGlobal(logRoot, source);
		if (years.isEmpty()) {
			System.out.println("no logs for source: " + source);
			return;
		}
		System.out.println(source + "/");
		for (String year : years) {
			System.out.println(year + "/");
		}
	}

	private static void printSourceMonthsGlobal(File logRoot, String source, String year) {
		List<String> months = listMonthsForSourceGlobal(logRoot, source, year);
		if (months.isEmpty()) {
			System.out.println("no logs for source: " + source + " year=" + year);
			return;
		}
		System.out.println(source + "/" + year + "/");
		for (String month : months) {
			System.out.println(month + "/");
		}
	}

	private static void printSourceLogsGlobal(File logRoot, String source, String year, String month) {
		List<LogEntry> entries = listLogsForSourceGlobal(logRoot, source, year, month);
		if (entries.isEmpty()) {
			System.out.println("no logs for source: " + source + " " + year + "/" + month);
			return;
		}
		for (LogEntry entry : entries) {
			String dateStr = entry.date == null ? "-" : entry.date.toString();
			System.out.println(dateStr + "  " + entry.config + "/" + entry.file.getName());
		}
	}

	private static java.util.Map<String, LocalDate> latestLogBySourceInConfig(File configDir) {
		java.util.Map<String, LocalDate> latest = new java.util.HashMap<>();
		if (configDir == null || !configDir.exists()) {
			return latest;
		}
		File[] yearDirs = configDir.listFiles(file -> file.isDirectory() && file.getName().matches("\\d{4}"));
		if (yearDirs == null) {
			return latest;
		}
		for (File yearDir : yearDirs) {
			File[] monthDirs = yearDir.listFiles(file -> file.isDirectory() && file.getName().matches("\\d{2}"));
			if (monthDirs == null) {
				continue;
			}
			for (File monthDir : monthDirs) {
				File[] sourceDirs = monthDir.listFiles(File::isDirectory);
				if (sourceDirs == null) {
					continue;
				}
				for (File sourceDir : sourceDirs) {
					File[] logs = sourceDir.listFiles(
							file -> file.isFile() && file.getName().startsWith("log_") && file.getName().endsWith(".json"));
					if (logs == null) {
						continue;
					}
					for (File log : logs) {
						LocalDate date = parseDateFromLogFile(log.getName());
						if (date == null) {
							continue;
						}
						String source = sourceDir.getName();
						LocalDate current = latest.get(source);
						if (current == null || date.isAfter(current)) {
							latest.put(source, date);
						}
					}
				}
			}
		}
		return latest;
	}

	private static List<String> listYearsForSourceInConfig(File configDir, String source) {
		Set<String> years = new TreeSet<>();
		if (configDir == null || !configDir.exists()) {
			return new ArrayList<>(years);
		}
		File[] yearDirs = configDir.listFiles(file -> file.isDirectory() && file.getName().matches("\\d{4}"));
		if (yearDirs == null) {
			return new ArrayList<>(years);
		}
		for (File yearDir : yearDirs) {
			if (hasSourceInYear(yearDir, source)) {
				years.add(yearDir.getName());
			}
		}
		return new ArrayList<>(years);
	}

	private static List<String> listMonthsForSourceInConfig(File configDir, String source, String year) {
		Set<String> months = new TreeSet<>();
		if (configDir == null || !configDir.exists()) {
			return new ArrayList<>(months);
		}
		File yearDir = new File(configDir, year);
		if (!yearDir.exists()) {
			return new ArrayList<>(months);
		}
		File[] monthDirs = yearDir.listFiles(file -> file.isDirectory() && file.getName().matches("\\d{2}"));
		if (monthDirs == null) {
			return new ArrayList<>(months);
		}
		for (File monthDir : monthDirs) {
			File sourceDir = new File(monthDir, source);
			if (sourceDir.exists()) {
				months.add(monthDir.getName());
			}
		}
		return new ArrayList<>(months);
	}

	private static List<File> listLogsForSourceInConfig(File configDir, String source, String year, String month) {
		List<File> logs = new ArrayList<>();
		if (configDir == null || !configDir.exists()) {
			return logs;
		}
		File sourceDir = new File(configDir, year + "/" + month + "/" + source);
		if (!sourceDir.exists()) {
			return logs;
		}
		File[] files = sourceDir.listFiles(
				file -> file.isFile() && file.getName().startsWith("log_") && file.getName().endsWith(".json"));
		if (files != null) {
			Collections.addAll(logs, files);
			logs.sort(Comparator.comparing(File::getName));
		}
		return logs;
	}

	private static List<String> listYearsForSourceGlobal(File logRoot, String source) {
		Set<String> years = new TreeSet<>();
		for (File configDir : listConfigDirs(logRoot)) {
			years.addAll(listYearsForSourceInConfig(configDir, source));
		}
		return new ArrayList<>(years);
	}

	private static List<String> listMonthsForSourceGlobal(File logRoot, String source, String year) {
		Set<String> months = new TreeSet<>();
		for (File configDir : listConfigDirs(logRoot)) {
			months.addAll(listMonthsForSourceInConfig(configDir, source, year));
		}
		return new ArrayList<>(months);
	}

	private static List<LogEntry> listLogsForSourceGlobal(File logRoot, String source, String year, String month) {
		List<LogEntry> entries = new ArrayList<>();
		for (File configDir : listConfigDirs(logRoot)) {
			List<File> logs = listLogsForSourceInConfig(configDir, source, year, month);
			for (File log : logs) {
				LogEntry entry = new LogEntry();
				entry.config = configDir.getName();
				entry.file = log;
				entry.date = parseDateFromLogFile(log.getName());
				entries.add(entry);
			}
		}
		entries.sort((a, b) -> {
			if (a.date == null && b.date == null) {
				return a.config.compareTo(b.config);
			}
			if (a.date == null) {
				return 1;
			}
			if (b.date == null) {
				return -1;
			}
			int cmp = a.date.compareTo(b.date);
			if (cmp != 0) {
				return cmp;
			}
			return a.config.compareTo(b.config);
		});
		return entries;
	}

	private static boolean hasSourceInYear(File yearDir, String source) {
		File[] monthDirs = yearDir.listFiles(file -> file.isDirectory() && file.getName().matches("\\d{2}"));
		if (monthDirs == null) {
			return false;
		}
		for (File monthDir : monthDirs) {
			File sourceDir = new File(monthDir, source);
			if (sourceDir.exists()) {
				return true;
			}
		}
		return false;
	}

	private static List<File> resolveLogFiles(File configDir, String source, LocalDateTime start, LocalDateTime end) {
		List<File> files = new ArrayList<>();
		if (configDir == null || source == null || source.trim().isEmpty()) {
			return files;
		}
		if (start == null || end == null) {
			File latest = findLatestLogFile(configDir, source);
			if (latest != null) {
				files.add(latest);
			}
			return files;
		}
		LocalDate cursor = start.toLocalDate();
		LocalDate endDate = end.toLocalDate();
		DateTimeFormatter ymd = DateTimeFormatter.BASIC_ISO_DATE;
		while (!cursor.isAfter(endDate)) {
			String year = String.format("%04d", cursor.getYear());
			String month = String.format("%02d", cursor.getMonthValue());
			String ymdStr = cursor.format(ymd);
			File file = new File(configDir,
					year + "/" + month + "/" + source + "/log_" + ymdStr + ".json");
			if (file.exists()) {
				files.add(file);
			}
			cursor = cursor.plusDays(1);
		}
		return files;
	}

	private static File findLatestLogFile(File configDir, String source) {
		if (configDir == null || source == null || source.trim().isEmpty()) {
			return null;
		}
		List<File> candidates = new ArrayList<>();
		File[] yearDirs = configDir.listFiles(file -> file.isDirectory() && file.getName().matches("\\d{4}"));
		if (yearDirs == null) {
			return null;
		}
		for (File yearDir : yearDirs) {
			File[] monthDirs = yearDir.listFiles(file -> file.isDirectory() && file.getName().matches("\\d{2}"));
			if (monthDirs == null) {
				continue;
			}
			for (File monthDir : monthDirs) {
				File sourceDir = new File(monthDir, source);
				if (!sourceDir.exists()) {
					continue;
				}
				File[] logs = sourceDir.listFiles(
						file -> file.isFile() && file.getName().startsWith("log_") && file.getName().endsWith(".json"));
				if (logs != null) {
					Collections.addAll(candidates, logs);
				}
			}
		}
		if (candidates.isEmpty()) {
			return null;
		}
		return Collections.max(candidates, Comparator.comparing(File::getName));
	}

	private static ConfigChoice findBestConfigForSource(File logRoot, String source) {
		List<File> configs = listConfigDirs(logRoot);
		File best = null;
		LocalDate bestDate = null;
		int matches = 0;
		for (File configDir : configs) {
			LocalDate date = latestLogDateForSource(configDir, source);
			if (date == null) {
				continue;
			}
			matches++;
			if (bestDate == null || date.isAfter(bestDate)) {
				bestDate = date;
				best = configDir;
			}
		}
		if (best == null) {
			return null;
		}
		ConfigChoice choice = new ConfigChoice();
		choice.configDir = best;
		choice.multiple = matches > 1;
		choice.latestDate = bestDate;
		return choice;
	}

	private static LocalDate latestLogDateForSource(File configDir, String source) {
		LocalDate latest = null;
		if (configDir == null || !configDir.exists()) {
			return null;
		}
		File[] yearDirs = configDir.listFiles(file -> file.isDirectory() && file.getName().matches("\\d{4}"));
		if (yearDirs == null) {
			return null;
		}
		for (File yearDir : yearDirs) {
			File[] monthDirs = yearDir.listFiles(file -> file.isDirectory() && file.getName().matches("\\d{2}"));
			if (monthDirs == null) {
				continue;
			}
			for (File monthDir : monthDirs) {
				File sourceDir = new File(monthDir, source);
				if (!sourceDir.exists()) {
					continue;
				}
				File[] logs = sourceDir.listFiles(
						file -> file.isFile() && file.getName().startsWith("log_") && file.getName().endsWith(".json"));
				if (logs == null) {
					continue;
				}
				for (File log : logs) {
					LocalDate date = parseDateFromLogFile(log.getName());
					if (date == null) {
						continue;
					}
					if (latest == null || date.isAfter(latest)) {
						latest = date;
					}
				}
			}
		}
		return latest;
	}

	private static List<File> listConfigDirs(File logRoot) {
		List<File> configs = new ArrayList<>();
		if (logRoot == null || !logRoot.exists()) {
			return configs;
		}
		if (isConfigDir(logRoot)) {
			configs.add(logRoot);
			return configs;
		}
		File[] dirs = logRoot.listFiles(File::isDirectory);
		if (dirs != null) {
			for (File dir : dirs) {
				if (isConfigDir(dir)) {
					configs.add(dir);
				}
			}
		}
		return configs;
	}

	private static File findConfigDir(File logRoot, String name) {
		if (logRoot == null || name == null || name.trim().isEmpty()) {
			return null;
		}
		File candidate = new File(logRoot, name);
		return isConfigDir(candidate) ? candidate : null;
	}

	private static boolean isConfigDir(File dir) {
		if (dir == null || !dir.exists() || !dir.isDirectory()) {
			return false;
		}
		if (hasConfigChildren(dir)) {
			return false;
		}
		File cfg = new File(dir, "config.json");
		if (cfg.exists()) {
			return true;
		}
		File[] yearDirs = dir.listFiles(file -> file.isDirectory() && file.getName().matches("\\d{4}"));
		return yearDirs != null && yearDirs.length > 0;
	}

	private static boolean hasConfigChildren(File dir) {
		File[] dirs = dir.listFiles(File::isDirectory);
		if (dirs == null) {
			return false;
		}
		for (File child : dirs) {
			File cfg = new File(child, "config.json");
			if (cfg.exists()) {
				return true;
			}
		}
		return false;
	}

	private static LocalDate parseDateFromLogFile(String name) {
		if (name == null || !name.startsWith("log_") || !name.endsWith(".json")) {
			return null;
		}
		String ymd = name.substring(4, name.length() - 5);
		if (!ymd.matches("\\d{8}")) {
			return null;
		}
		int year = Integer.parseInt(ymd.substring(0, 4));
		int month = Integer.parseInt(ymd.substring(4, 6));
		int day = Integer.parseInt(ymd.substring(6, 8));
		return LocalDate.of(year, month, day);
	}

	private static LocalDate maxDate(java.util.Collection<LocalDate> dates) {
		LocalDate latest = null;
		if (dates == null) {
			return null;
		}
		for (LocalDate date : dates) {
			if (date == null) {
				continue;
			}
			if (latest == null || date.isAfter(latest)) {
				latest = date;
			}
		}
		return latest;
	}

	private static String formatSourceSummary(java.util.Set<String> sources, int maxNames) {
		if (sources == null || sources.isEmpty()) {
			return "sources: -";
		}
		List<String> names = new ArrayList<>(sources);
		Collections.sort(names);
		StringBuilder sb = new StringBuilder("sources: ");
		int count = names.size();
		int limit = Math.min(maxNames, count);
		for (int i = 0; i < limit; i++) {
			if (i > 0) {
				sb.append(", ");
			}
			sb.append(names.get(i));
		}
		if (count > limit) {
			sb.append(" (+").append(count - limit).append(")");
		}
		return sb.toString();
	}

	private static class ConfigChoice {
		File configDir;
		boolean multiple;
		LocalDate latestDate;
	}

	private static class LogEntry {
		String config;
		File file;
		LocalDate date;
	}

	private static class WatchArgs {
		String source;
		String configName;
		String file;
		String path;
		String time1;
		String time2;
		String tag;
		String name;
		Integer head;
		Integer tail;
		boolean csv;
		String mode;
		boolean follow;
	}

	private static class LsArgs {
		String target;
		String path;
	}

	private static boolean isVersionRequest(String[] args) {
		if (args == null || args.length == 0) {
			return false;
		}
		for (String arg : args) {
			if (arg == null) {
				continue;
			}
			String value = arg.trim();
			if (value.equalsIgnoreCase("version") || value.equalsIgnoreCase("-version")
					|| value.equalsIgnoreCase("--version") || value.equalsIgnoreCase("-v")) {
				return true;
			}
		}
		return false;
	}

	private static void printVersion() {
		String version = getVersion();
		System.out.println("gop " + version);
	}

	private static String getVersion() {
		Package pkg = Gop.class.getPackage();
		if (pkg != null) {
			String v = pkg.getImplementationVersion();
			if (v != null && !v.isEmpty()) {
				return v;
			}
		}
		return "dev";
	}

	private void printInfo(SourceConfig source, Config config) {
		try {
			String currentPath = new java.io.File(".").getCanonicalPath();
			System.out.println("Current dir : " + currentPath);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		System.out.println("Source : " + (source.source == null ? "-" : source.source));
		String jdbcUrl = source.jdbcSource == null ? "-" : source.jdbcSource.url;
		System.out.println("Source jdbc url : " + jdbcUrl);
		boolean writeFile = config.setting != null && config.setting.fileLog != null && config.setting.fileLog.enable;
		String filePath = config.setting == null || config.setting.fileLog == null ? "-" : config.setting.fileLog.logPath;
		System.out.println("Write file : " + writeFile);
		System.out.println("Write file path : " + filePath);
	}

	private static void printTableMap(LinkedHashMap<LocalDateTime, ResultCommon[]> rangeTimeMap, int head, int tail, Boolean printCSV) {
		if (rangeTimeMap.isEmpty()) {
			System.out.println("no data!");
			System.exit(0);
		}
		Set<LocalDateTime> timeKeys = rangeTimeMap.keySet();
		int i = 0;
		boolean gColumn = true;

		Data sumDt = null;
		for (LocalDateTime key : timeKeys) {
			// System.out.println(key);

			if (head > 0) {
				if (i < head) {
					Data data = new Data(timestampToString(key), rangeTimeMap.get(key));
					gColumn = printTable(data, gColumn, printCSV);
					sumDt=sumData(sumDt,data);
					// System.out.println("head: " +i);
				}
			} else if (tail > 0) {
				if (timeKeys.size() - tail <= i) {
					Data data = new Data(timestampToString(key), rangeTimeMap.get(key));
					gColumn = printTable(data, gColumn, printCSV);
					sumDt=sumData(sumDt,data);
					// System.out.println("tail: " +i);
				}
			} else {
				Data data = new Data(timestampToString(key), rangeTimeMap.get(key));
				gColumn = printTable(data, gColumn, printCSV);
				sumDt=sumData(sumDt,data);
			}
			i++;
		}
		printTable(sumDt,false,printCSV);
		int avgNum=0;
		if(head > 0){
			avgNum=head;
		}else if (tail > 0){
			avgNum=tail;
		}else{
			avgNum=timeKeys.size();
		}
		printTable(avgData(sumDt,avgNum),false,printCSV);
	}

	private static Data avgData(Data sumDt, int size) {
		sumDt.time = "AVG:                     ";

		for (ResultCommon rc : sumDt.rc) {
			rc.value = rc.value/size;
		}

		return sumDt;
	}

	private static Data sumData(Data sumDt, Data data) {
		if(sumDt == null){
			sumDt = data;
			sumDt.time = "SUM:                     ";
		}else{
		   for (int i = 0; i < data.rc.length; i++) {
			sumDt.rc[i].value += data.rc[i].value;
		   }
		}
		return sumDt;
	}

	private static LocalDateTime stringToDate(String startSearchKey) {

		try {
			DateTimeFormatter formatDateTime = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSS");
			LocalDateTime localDateTime = LocalDateTime.from(formatDateTime.parse(startSearchKey));
			return localDateTime;
		} catch (java.time.format.DateTimeParseException e) {
			// TODO: handle exceptionA
			System.out.println("invalid time : " + startSearchKey);
			System.exit(0);
		}
		return null;
	}

	private void startMonitoring(Config config, Gson gson, boolean runOnce, boolean allowPrint, boolean allowFileLog) throws Exception {
		SourceConfig[] sources = resolveSources(config);
		if (runOnce) {
			java.util.concurrent.ConcurrentHashMap<String, Data> results = new java.util.concurrent.ConcurrentHashMap<>();
			Thread[] threads = new Thread[sources.length];
			for (int i = 0; i < sources.length; i++) {
				SourceConfig source = sources[i];
				printInfo(source, config);
				threads[i] = new Thread(() -> {
					try {
						Data data = collectOnce(config, source, gson);
						if (data != null) {
							results.put(source.source, data);
						}
					} catch (Exception e) {
						e.printStackTrace();
					}
				});
				threads[i].setDaemon(false);
				threads[i].start();
			}
			for (Thread t : threads) {
				t.join();
			}
			if (allowPrint && config.setting.consolePrint) {
				String cycleTime = java.time.format.DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSS")
						.format(java.time.LocalDateTime.now());
				RunOutputFormatter.printRunSections(new java.util.ArrayList<>(results.values()), config.setting.printCSV, cycleTime);
			}
		} else {
			Thread[] threads = new Thread[sources.length];
			for (int i = 0; i < sources.length; i++) {
				SourceConfig source = sources[i];
				printInfo(source, config);
				threads[i] = new Thread(() -> {
					try {
						gStampLog(config, source, gson, runOnce, allowPrint, allowFileLog);
					} catch (Exception e) {
						e.printStackTrace();
					}
				});
				threads[i].setDaemon(false);
				threads[i].start();
			}
		}
	}

	private void runLoop(Config config, Gson gson, boolean showInfo) throws Exception {
		SourceConfig[] sources = resolveSources(config);
		if (showInfo) {
			for (SourceConfig source : sources) {
				printInfo(source, config);
			}
		}
		java.util.concurrent.ConcurrentHashMap<String, Database.ConnAndStmt> connCache = new java.util.concurrent.ConcurrentHashMap<>();
		Runtime.getRuntime().addShutdownHook(new Thread(() -> closeRunConnections(connCache)));
		java.util.concurrent.ExecutorService exec = java.util.concurrent.Executors
				.newFixedThreadPool(Math.max(1, sources.length));
		Runtime.getRuntime().addShutdownHook(new Thread(() -> exec.shutdownNow()));
		while (true) {
			java.util.concurrent.ConcurrentHashMap<String, Data> results = new java.util.concurrent.ConcurrentHashMap<>();
			java.util.List<java.util.concurrent.Future<Data>> futures = new java.util.ArrayList<>();
			for (int i = 0; i < sources.length; i++) {
				SourceConfig source = sources[i];
				futures.add(exec.submit(() -> collectOnceReuse(config, source, gson, connCache)));
			}
			for (java.util.concurrent.Future<Data> f : futures) {
				try {
					Data data = f.get();
					if (data != null) {
						String key = data.source == null ? "default" : data.source;
						results.put(key, data);
					}
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
			if (config.setting.consolePrint) {
				String cycleTime = java.time.format.DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSS")
						.format(java.time.LocalDateTime.now());
				RunOutputFormatter.printRunSections(new java.util.ArrayList<>(results.values()), config.setting.printCSV, cycleTime);
			}
			Thread.sleep(config.setting.timeInterval);
		}
	}

	private static SourceConfig[] resolveSources(Config config) {
		if (config.sources != null && config.sources.length > 0) {
			return config.sources;
		}
		return new SourceConfig[] { buildSingleSource(config) };
	}

	private static SourceConfig buildSingleSource(Config config) {
		SourceConfig source = new SourceConfig();
		source.source = config.setting.source == null ? "default" : config.setting.source;
		source.jdbcSource = config.setting.jdbcSource;
		source.measure = config.measure;
		source.measureV2 = config.measureV2;
		return source;
	}

	private static void gStampLog(Config config, SourceConfig source, Gson gson, boolean runOnce, boolean allowPrint, boolean allowFileLog)
			throws Exception {
		if (isV2Source(source)) {
			gStampLogV2(config, source, gson, runOnce, allowPrint, allowFileLog);
			return;
		}

		// db
		Database db = new Database(source.jdbcSource, source.measure, source.source);

		int printRow = 0;
		Data beforeData = new Data(null, null);
		Data calData = new Data(null, null);

		PreparedStatement[] arrPstmt = null;

		arrPstmt = db.createConAndPstmt(db);
		boolean firstSkip = true;
		boolean gColumn = true;

		while (true) {
			Data data = null;
			int i = 0;
			do {
				data = db.getCommonQuery(arrPstmt);
				if (data != null) {
					continue;
				}
				arrPstmt = db.createConAndPstmt(db);

				System.out.println("getCommonQuery error retry cnt : " + i);
				i++;
				Thread.sleep(1000);
			} while (data == null);

			// ResultCommon[] rc2 = db.getOsQuery();

			// write output file (json)
			if (beforeData.rc == null) {
				calData = data.newInstance(data);
				beforeData = data.newInstance(data);
			} else {
				calData = diffDataCal(data, beforeData, source.measure);
				beforeData = data.newInstance(data);
			}

			if (!firstSkip || runOnce){
				if (allowFileLog && config.setting.fileLog.enable) {
					FileLogService.writeJson(calData, gson, config, source.measure);
				}
				// print console (table)
				if (allowPrint && config.setting.consolePrint) {
					gColumn = printTable(calData,gColumn,config.setting.printCSV);
					printRow++;
					if (printRow % config.setting.pageSize == 0) {
						gColumn = true;
					}
				}
			}else{
				firstSkip=false;
			}
			data = null;
			// rc2 = null;
			if (runOnce) {
				break;
			}
			Thread.sleep(config.setting.timeInterval);
		}
	}

	private static Data collectOnce(Config config, SourceConfig source, Gson gson) throws Exception {
		if (isV2Source(source)) {
			return collectOnceV2(source);
		}
		Database db = new Database(source.jdbcSource, source.measure, source.source);
		Database.ConnAndStmt cas = db.createConAndPstmtWithConnection();
		Data data = null;
		int i = 0;
		try {
			do {
				data = db.getCommonQuery(cas.stmts);
				if (data != null) {
					break;
				}
				cas = db.createConAndPstmtWithConnection();
				System.out.println("getCommonQuery error retry cnt : " + i);
				i++;
				Thread.sleep(1000);
			} while (data == null);
			return data;
		} finally {
			if (cas != null && cas.con != null) {
				try {
					cas.con.close();
				} catch (Exception ignored) {
				}
			}
		}
	}

	private static Data collectOnceReuse(Config config, SourceConfig source, Gson gson,
			java.util.concurrent.ConcurrentHashMap<String, Database.ConnAndStmt> connCache) throws Exception {
		if (isV2Source(source)) {
			return collectOnceV2(source);
		}
		Database db = new Database(source.jdbcSource, source.measure, source.source);
		String key = source.source == null ? "default" : source.source;
		Database.ConnAndStmt cas = connCache.get(key);
		if (cas == null || cas.con == null || cas.con.isClosed()) {
			cas = db.createConAndPstmtWithConnection();
			connCache.put(key, cas);
		}
		Data data = null;
		int i = 0;
		do {
			data = db.getCommonQuery(cas.stmts);
			if (data != null) {
				break;
			}
			closeConn(cas);
			cas = db.createConAndPstmtWithConnection();
			connCache.put(key, cas);
			System.out.println("getCommonQuery error retry cnt : " + i);
			i++;
			Thread.sleep(1000);
		} while (data == null);
		return data;
	}

	private static void closeConn(Database.ConnAndStmt cas) {
		if (cas == null || cas.con == null) {
			return;
		}
		try {
			cas.con.close();
		} catch (Exception ignored) {
		}
	}

	private static void closeRunConnections(java.util.concurrent.ConcurrentHashMap<String, Database.ConnAndStmt> connCache) {
		for (Database.ConnAndStmt cas : connCache.values()) {
			closeConn(cas);
		}
	}

	private static boolean isV2Source(SourceConfig source) {
		return source != null && source.measureV2 != null && source.measureV2.length > 0;
	}

	private static void gStampLogV2(Config config, SourceConfig source, Gson gson, boolean runOnce, boolean allowPrint,
			boolean allowFileLog) throws Exception {
		int printRow = 0;
		boolean gColumn = true;

		while (true) {
			Data data = null;
			int retry = 0;
			do {
				data = collectOnceV2(source);
				if (data != null) {
					break;
				}
				System.out.println("collectOnceV2 error retry cnt : " + retry);
				retry++;
				Thread.sleep(1000);
			} while (data == null);

			if (allowFileLog && config.setting != null && config.setting.fileLog != null && config.setting.fileLog.enable) {
				FileLogService.writeJson(data, gson, config, null);
			}
			if (allowPrint && config.setting != null && config.setting.consolePrint) {
				gColumn = printTable(data, gColumn, config.setting.printCSV);
				printRow++;
				if (config.setting.pageSize > 0 && printRow % config.setting.pageSize == 0) {
					gColumn = true;
				}
			}

			if (runOnce) {
				break;
			}
			Thread.sleep(config.setting.timeInterval);
		}
	}

	private static Data collectOnceV2(SourceConfig source) throws Exception {
		List<ResultCommon> resultList = new ArrayList<>();
		String sourceId = source.source == null ? "default" : source.source;
		DateTimeFormatter formatDateTime = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSS");
		String sysTimestamp = formatDateTime.format(LocalDateTime.now());

		boolean needsDb = false;
		for (MeasureV2 measure : source.measureV2) {
			if (measure != null && !measure.sqlIsOs && measure.sql != null && !measure.sql.trim().isEmpty()) {
				needsDb = true;
				break;
			}
		}
		if (!needsDb) {
			for (MeasureV2 measure : source.measureV2) {
				if (measure == null || measure.sql == null || measure.sql.trim().isEmpty()) {
					continue;
				}
				Map<String, TargetV2> targetMap = buildTargetMap(measure.targets);
				long rawValue = parseLong(ReadOs.executeS(measure.sql));
				processV2Row(sourceId, measure, null, rawValue, targetMap, resultList);
			}
			return new Data(sysTimestamp, sourceId, resultList.toArray(new ResultCommon[0]));
		}
		if (source.jdbcSource == null) {
			System.out.println("invalid source config: jdbcSource is required for SQL measureV2 (" + sourceId + ")");
			System.exit(0);
		}

		Database db = new Database(source.jdbcSource, new Measure[0], source.source);
		try (Connection con = db.createConnection()) {
			for (MeasureV2 measure : source.measureV2) {
				if (measure == null || measure.sql == null || measure.sql.trim().isEmpty()) {
					continue;
				}
				Map<String, TargetV2> targetMap = buildTargetMap(measure.targets);
				if (measure.sqlIsOs) {
					long rawValue = parseLong(ReadOs.executeS(measure.sql));
					processV2Row(sourceId, measure, null, rawValue, targetMap, resultList);
					continue;
				}
				try (PreparedStatement pstmt = con.prepareStatement(measure.sql);
						ResultSet rs = pstmt.executeQuery()) {
					while (rs.next()) {
						String targetKey = readTargetKey(rs, measure);
						long rawValue = readLongValue(rs, measure);
						processV2Row(sourceId, measure, targetKey, rawValue, targetMap, resultList);
					}
				}
			}
		}
		return new Data(sysTimestamp, sourceId, resultList.toArray(new ResultCommon[0]));
	}

	private static Map<String, TargetV2> buildTargetMap(TargetV2[] targets) {
		Map<String, TargetV2> map = new HashMap<>();
		if (targets == null) {
			return map;
		}
		for (TargetV2 target : targets) {
			if (target == null || target.target == null || target.target.trim().isEmpty()) {
				continue;
			}
			map.put(target.target.trim(), target);
		}
		return map;
	}

	private static String readTargetKey(ResultSet rs, MeasureV2 measure) throws SQLException {
		String targetColumn = measure.targetColumn;
		if (targetColumn != null && !targetColumn.trim().isEmpty()) {
			return rs.getString(targetColumn.trim());
		}
		try {
			return rs.getString(1);
		} catch (SQLException ignored) {
			return null;
		}
	}

	private static long readLongValue(ResultSet rs, MeasureV2 measure) throws SQLException {
		String valueColumn = measure.valueColumn;
		if (valueColumn != null && !valueColumn.trim().isEmpty()) {
			long val = rs.getLong(valueColumn.trim());
			return rs.wasNull() ? 0L : val;
		}
		try {
			long val = rs.getLong(2);
			if (!rs.wasNull()) {
				return val;
			}
		} catch (SQLException ignored) {
		}
		long val = rs.getLong(1);
		return rs.wasNull() ? 0L : val;
	}

	private static void processV2Row(String sourceId, MeasureV2 measure, String targetKey, long rawValue,
			Map<String, TargetV2> targetMap, List<ResultCommon> resultList) {
		TargetV2 targetCfg = null;
		if (targetKey != null && !targetKey.trim().isEmpty()) {
			targetCfg = targetMap.get(targetKey.trim());
		}
		if (targetCfg == null && targetMap.size() == 1) {
			targetCfg = targetMap.values().iterator().next();
		}

		String measureName;
		String viewMode = "raw";
		String tag = measure.defaultTag;
		RuleV2[] rules = null;
		String normalizedTarget = targetKey == null ? null : targetKey.trim();

		if (targetCfg != null) {
			measureName = firstNonBlank(targetCfg.measure, normalizedTarget, measure.name);
			viewMode = firstNonBlank(targetCfg.viewMode, "raw");
			tag = firstNonBlank(targetCfg.tag, measure.defaultTag);
			rules = targetCfg.rules;
		} else if (targetMap.isEmpty()) {
			measureName = firstNonBlank(normalizedTarget, measure.name);
		} else {
			return;
		}

		if (measureName == null || measureName.trim().isEmpty()) {
			return;
		}
		long value = applyViewMode(sourceId, measureName, rawValue, viewMode);
		RuleEvalResult eval = evaluateRulesAndRunActions(sourceId, measureName, value, rules);
		String[] actionStates = eval.actionStates.toArray(new String[0]);
		resultList.add(new ResultCommon(measureName, value, tag, eval.alert, normalizedTarget, actionStates));
	}

	private static long applyViewMode(String sourceId, String measureName, long rawValue, String viewMode) {
		String mode = viewMode == null ? "raw" : viewMode.trim().toLowerCase();
		if ("delta".equals(mode)) {
			String key = sourceId + "|" + measureName;
			Long prev = V2_PREVIOUS_VALUES.put(key, rawValue);
			return prev == null ? 0L : rawValue - prev;
		}
		return rawValue;
	}

	private static class RuleEvalResult {
		boolean alert;
		LinkedHashSet<String> actionStates = new LinkedHashSet<>();
	}

	private static RuleEvalResult evaluateRulesAndRunActions(String sourceId, String measureName, long value, RuleV2[] rules) {
		RuleEvalResult result = new RuleEvalResult();
		if (rules == null || rules.length == 0) {
			return result;
		}
		for (RuleV2 rule : rules) {
			if (rule == null) {
				continue;
			}
			if (!matchRule(rule, value)) {
				continue;
			}
			if (rule.actions == null || rule.actions.length == 0) {
				result.alert = true;
				result.actionStates.add("alert");
				continue;
			}
			for (ActionV2 action : rule.actions) {
				if (action == null || action.type == null) {
					continue;
				}
				String actionType = action.type.trim().toLowerCase();
				String actionName = firstNonBlank(action.name, action.type);
				if ("alert".equals(actionType)) {
					result.alert = true;
					result.actionStates.add(actionName);
					continue;
				}
				if ("script".equals(actionType)) {
					runScriptAction(action);
					result.actionStates.add(actionName);
					continue;
				}
				if ("notify".equals(actionType)) {
					String msg = formatNotifyMessage(action.message, sourceId, measureName, value);
					System.out.println(msg);
					result.actionStates.add(actionName);
				}
			}
		}
		return result;
	}

	private static boolean matchRule(RuleV2 rule, long value) {
		String op = rule.operator == null ? "gt" : rule.operator.trim().toLowerCase();
		switch (op) {
		case "gt":
			return value > rule.threshold;
		case "gte":
			return value >= rule.threshold;
		case "lt":
			return value < rule.threshold;
		case "lte":
			return value <= rule.threshold;
		case "eq":
			return value == rule.threshold;
		case "ne":
			return value != rule.threshold;
		default:
			return false;
		}
	}

	private static void runScriptAction(ActionV2 action) {
		if (action.script == null || action.script.trim().isEmpty()) {
			return;
		}
		if (action.scriptIsOs) {
			ReadOs.executeS(action.script);
			return;
		}
		String escaped = action.script.replace("'", "'\"'\"'");
		String sqlCmd = "echo '" + escaped + ";' |gsqlnet sys gliese --no-prompt";
		ReadOs.executeS(sqlCmd);
	}

	private static String formatNotifyMessage(String messageTemplate, String sourceId, String measureName, long value) {
		String template = messageTemplate == null || messageTemplate.trim().isEmpty()
				? "[notify] {{source}} {{measure}}={{value}}"
				: messageTemplate;
		return template.replace("{{source}}", sourceId == null ? "-" : sourceId)
				.replace("{{measure}}", measureName == null ? "-" : measureName)
				.replace("{{value}}", String.valueOf(value));
	}

	private static String firstNonBlank(String... values) {
		if (values == null) {
			return null;
		}
		for (String value : values) {
			if (value != null && !value.trim().isEmpty()) {
				return value.trim();
			}
		}
		return null;
	}

	private static long parseLong(String value) {
		if (value == null || value.trim().isEmpty()) {
			return 0L;
		}
		try {
			return Long.parseLong(value.trim());
		} catch (NumberFormatException e) {
			return 0L;
		}
	}

	private static Data diffDataCal(Data data, Data beforeData, model.Measure[] measure) {
		// Data tempData = new Data(data.time, data.rc);
		// ResultCommon[] rc = new ResultCommon[data.rc.length];
		// Data tempData = new Data(data.time, rc);
		Data cal = data.newInstance(data);
		for (int i = 0; i < data.rc.length; i++) {
			if (measure[i].diff) {
				cal.rc[i].value = data.rc[i].value - beforeData.rc[i].value;
			}
		}
		return cal;
	}

	private static String timestampToString(LocalDateTime timestamp) {
		DateTimeFormatter formatDateTime = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSS");
		return formatDateTime.format(timestamp);
	}

	private static Config readAndConvConf(File rFile, Class<Config> class1, Gson gson) throws FileNotFoundException {
		try (FileInputStream fis = new FileInputStream(rFile);
				InputStreamReader isr = new InputStreamReader(fis, StandardCharsets.UTF_8);
				BufferedReader reader = new BufferedReader(isr)) {
			Config config = gson.fromJson(reader, Config.class);
			if (config == null) {
				System.out.println("invalid config file: empty json");
				System.exit(0);
			}

			if (config.setting == null && config.server != null) {
				config.setting = config.server;
			}
			if ((config.sources == null || config.sources.length == 0)
					&& config.server != null && config.server.sourceRefs != null && config.server.sourceRefs.length > 0) {
				config.sources = loadSourceConfigs(rFile, config.server.sourceRefs, gson);
			}
			if (config.setting == null) {
				System.out.println("invalid config: missing setting/server");
				System.exit(0);
			}
			return config;
		} catch (IOException e) {
			FileNotFoundException ex = new FileNotFoundException(e.getMessage());
			ex.initCause(e);
			throw ex;
		}
	}

	private static SourceConfig[] loadSourceConfigs(File serverFile, String[] refs, Gson gson)
			throws FileNotFoundException {
		List<SourceConfig> sources = new ArrayList<>();
		for (String ref : refs) {
			if (ref == null || ref.trim().isEmpty()) {
				continue;
			}
			File sourceFile = resolveSourceFile(serverFile, ref.trim());
			if (sourceFile == null || !sourceFile.exists()) {
				System.out.println("source config not found: " + ref);
				System.exit(0);
			}
			SourceConfig source = readSourceConfig(sourceFile, gson);
			if (source.source == null || source.source.trim().isEmpty()) {
				source.source = sourceFile.getName().replaceFirst("\\.json$", "");
			}
			sources.add(source);
		}
		return sources.toArray(new SourceConfig[0]);
	}

	private static SourceConfig readSourceConfig(File sourceFile, Gson gson) throws FileNotFoundException {
		try (FileInputStream fis = new FileInputStream(sourceFile);
				InputStreamReader isr = new InputStreamReader(fis, StandardCharsets.UTF_8);
				BufferedReader reader = new BufferedReader(isr)) {
			SourceConfig source = gson.fromJson(reader, SourceConfig.class);
			if (source == null) {
				System.out.println("invalid source config: " + sourceFile.getPath());
				System.exit(0);
			}
			return source;
		} catch (IOException e) {
			FileNotFoundException ex = new FileNotFoundException(e.getMessage());
			ex.initCause(e);
			throw ex;
		}
	}

	private static File resolveSourceFile(File serverFile, String sourceRef) {
		File refFile = new File(sourceRef);
		if (refFile.isAbsolute()) {
			return refFile;
		}
		File baseDir = serverFile.getParentFile();
		List<File> candidates = new ArrayList<>();
		if (sourceRef.contains("/") || sourceRef.contains("\\") || sourceRef.endsWith(".json")) {
			candidates.add(new File(baseDir, sourceRef));
		} else {
			candidates.add(new File(baseDir, sourceRef + ".json"));
		}
		File parent = baseDir == null ? null : baseDir.getParentFile();
		if (parent != null) {
			if (sourceRef.endsWith(".json")) {
				candidates.add(new File(parent, "sources/" + sourceRef));
			} else {
				candidates.add(new File(parent, "sources/" + sourceRef + ".json"));
			}
		}
		for (File candidate : candidates) {
			if (candidate.exists()) {
				return candidate;
			}
		}
		return candidates.isEmpty() ? null : candidates.get(0);
	}

	private static void validateSourceDir(String source) {
		ConfigManager.validateId("source id", source);
	}

	private static Boolean printTable(Data data,Boolean gColumn,Boolean printCSV) {
		synchronized (PRINT_LOCK) {
		// TODO Auto-generated method stub
		String[] column = new String[data.rc.length];
		String[] row = new String[data.rc.length];

		for (int i = 0; i < data.rc.length; i++) {
			if (data.rc[i] != null) {
				column[i] = data.rc[i].measure;
				if(!printCSV){
					row[i] = alertFormat(data.rc[i].value, data.rc[i].alert);
				}else{
					row[i] = (","+data.rc[i].value);
				}
				// System.out.println(rc[i].toString());
			}
		}

		int i = 0;
		if (gColumn == true) {
			// System.out.println("** instance name :" + gName);

			System.out.println("");
			if(!printCSV){
				System.out.format("%24s  ", ANSI_GREEN + "time" + ANSI_RESET);
				System.out.format("%18s  ", ANSI_GREEN + "source" + ANSI_RESET);
				for (i = 0; i < row.length; i++) {
					if(column[i] != null) {
						System.out.format("%18s  ", ANSI_GREEN + column[i] + ANSI_RESET);
					}
				}
			}else{
				System.out.format("time");
				System.out.print(",source");
					for (i = 0; i < row.length; i++) {
						if(printCSV){
							System.out.print(","+column[i]);
						}else{
							if(column[i] != null) {
								System.out.format("%23s", ANSI_GREEN + column[i] + ANSI_RESET);
							}	
						}
					}
			}
			
			System.out.format("%n");
			gColumn = false;
		}

		for (i = 0; i < data.rc.length; i++) {
			if (data.rc[i] != null) {
				// System.out.println(rc[i].toString());
				if(!printCSV){
					System.out.format("%24s  ", ANSI_GREEN + data.time + ANSI_RESET);
					System.out.format("%18s  ", ANSI_GREEN + (data.source == null ? "-" : data.source) + ANSI_RESET);
				}else{
					System.out.format(data.time);
					System.out.print("," + (data.source == null ? "-" : data.source));
				}
				break;
			}
		}

		for (i = 0; i < row.length; i++) {
			if (row[i] != null) {
				if(!printCSV){
					System.out.format("%18s  ", row[i]);
				}else{
					System.out.format(row[i]);
				}
			}
		}
		System.out.format("%n");
		return gColumn;
		}
	}

	private static String alertFormat(long value, boolean alert) {
		String temp = null;
		if (alert) {
			temp = ANSI_RED + String.valueOf(value) + ANSI_RESET;
		} else {
			temp = ANSI_WHITE + String.valueOf(value) + ANSI_RESET;
		}
		return temp;
	}

	public Object startApp(String string, String string2) {
		return null;
	}
	
	public static final String ANSI_RESET = "\u001B[0m";
	public static final String ANSI_BLACK = "\u001B[30m";
	public static final String ANSI_RED = "\u001B[31m";
	public static final String ANSI_GREEN = "\u001B[32m";
	public static final String ANSI_YELLOW = "\u001B[33m";
	public static final String ANSI_BLUE = "\u001B[34m";
	public static final String ANSI_PURPLE = "\u001B[35m";
	public static final String ANSI_CYAN = "\u001B[36m";
	public static final String ANSI_WHITE = "\u001B[37m";
}
